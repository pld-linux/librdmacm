diff -Nur librdmacm-1.0.19/examples/rping.c librdmacm-1.0.19.ssa1/examples/rping.c
--- librdmacm-1.0.19/examples/rping.c	2014-07-17 00:30:15.000000000 +0200
+++ librdmacm-1.0.19.ssa1/examples/rping.c	2015-01-22 18:11:28.000000000 +0100
@@ -277,15 +277,20 @@
 	struct ibv_wc wc;
 	struct ibv_recv_wr *bad_wr;
 	int ret;
+	int flushed = 0;
 
 	while ((ret = ibv_poll_cq(cb->cq, 1, &wc)) == 1) {
 		ret = 0;
 
 		if (wc.status) {
-			if (wc.status != IBV_WC_WR_FLUSH_ERR)
-				fprintf(stderr,
-					"cq completion failed status %d\n",
-					wc.status);
+			if (wc.status == IBV_WC_WR_FLUSH_ERR) {
+				flushed = 1;
+				continue;
+
+			}
+			fprintf(stderr,
+				"cq completion failed status %d\n",
+				wc.status);
 			ret = -1;
 			goto error;
 		}
@@ -334,7 +339,7 @@
 		fprintf(stderr, "poll error %d\n", ret);
 		goto error;
 	}
-	return 0;
+	return flushed;
 
 error:
 	cb->state = ERROR;
@@ -1055,18 +1060,19 @@
 	ret = rping_connect_client(cb);
 	if (ret) {
 		fprintf(stderr, "connect error %d\n", ret);
-		goto err2;
+		goto err3;
 	}
 
 	ret = rping_test_client(cb);
 	if (ret) {
 		fprintf(stderr, "rping client failed: %d\n", ret);
-		goto err3;
+		goto err4;
 	}
 
 	ret = 0;
-err3:
+err4:
 	rdma_disconnect(cb->cm_id);
+err3:
 	pthread_join(cb->cqthread, NULL);
 err2:
 	rping_free_buffers(cb);
diff -Nur librdmacm-1.0.19/src/cma.c librdmacm-1.0.19.ssa1/src/cma.c
--- librdmacm-1.0.19/src/cma.c	2014-07-17 00:30:15.000000000 +0200
+++ librdmacm-1.0.19.ssa1/src/cma.c	2015-01-22 19:46:41.000000000 +0100
@@ -49,6 +49,7 @@
 #include <stddef.h>
 #include <netdb.h>
 #include <syslog.h>
+#include <limits.h>
 
 #include "cma.h"
 #include "indexer.h"
@@ -1035,7 +1036,9 @@
 static int ucma_modify_qp_rtr(struct rdma_cm_id *id, uint8_t resp_res)
 {
 	struct ibv_qp_attr qp_attr;
+	struct ibv_port_attr port_attr;
 	int qp_attr_mask, ret;
+	uint8_t link_layer;
 
 	if (!id->qp)
 		return ERR(EINVAL);
@@ -1055,6 +1058,17 @@
 	if (ret)
 		return ret;
 
+	/* Workaround for rdma_ucm kernel bug */
+	ret = ibv_query_port(id->verbs, id->port_num, &port_attr);
+	if (ret)
+		link_layer = IBV_LINK_LAYER_UNSPECIFIED;
+	else
+		link_layer = port_attr.link_layer;
+
+	if (id->verbs->device->transport_type == IBV_TRANSPORT_IB &&
+	    link_layer == IBV_LINK_LAYER_INFINIBAND)
+		qp_attr_mask &= UINT_MAX ^ 0xe00000;	/* mask off bits 21-24 which are used for RoCE */
+
 	if (resp_res != RDMA_MAX_RESP_RES)
 		qp_attr.max_dest_rd_atomic = resp_res;
 	return rdma_seterrno(ibv_modify_qp(id->qp, &qp_attr, qp_attr_mask));
diff -Nur librdmacm-1.0.19/src/preload.c librdmacm-1.0.19.ssa1/src/preload.c
--- librdmacm-1.0.19/src/preload.c	2014-07-17 00:30:15.000000000 +0200
+++ librdmacm-1.0.19.ssa1/src/preload.c	2015-01-22 18:11:29.000000000 +0100
@@ -50,6 +50,9 @@
 #include <netinet/tcp.h>
 #include <unistd.h>
 #include <semaphore.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <stdio.h>
 
 #include <rdma/rdma_cma.h>
 #include <rdma/rdma_verbs.h>
@@ -122,6 +125,136 @@
 	atomic_t refcnt;
 };
 
+struct config_entry {
+	char *name;
+	int domain;
+	int type;
+	int protocol;
+};
+
+static struct config_entry *config;
+static int config_cnt;
+extern char *program_invocation_short_name;
+
+
+static void free_config(void)
+{
+	while (config_cnt)
+		free(config[--config_cnt].name);
+
+	free(config);
+}
+
+/*
+ * Config file format:
+ * # Starting '#' indicates comment
+ * # wild card values are supported using '*'
+ * # domain - *, INET, INET6, IB
+ * # type - *, STREAM, DGRAM
+ * # protocol - *, TCP, UDP
+ * program_name domain type protocol
+ */
+static void scan_config(void)
+{
+	struct config_entry *new_config;
+	FILE *fp;
+	char line[120], prog[64], dom[16], type[16], proto[16];
+
+	fp = fopen(RS_CONF_DIR "/preload_config", "r");
+	if (!fp)
+		return;
+
+	while (fgets(line, sizeof(line), fp)) {
+		if (line[0] == '#')
+			continue;
+
+		if (sscanf(line, "%64s%16s%16s%16s", prog, dom, type, proto) != 4)
+			continue;
+
+		new_config = realloc(config, (config_cnt + 1) *
+					     sizeof(struct config_entry));
+		if (!new_config)
+			break;
+
+		config = new_config;
+		memset(&config[config_cnt], 0, sizeof(struct config_entry));
+
+		if (!strcasecmp(dom, "INET") ||
+		    !strcasecmp(dom, "AF_INET") ||
+		    !strcasecmp(dom, "PF_INET")) {
+			config[config_cnt].domain = AF_INET;
+		} else if (!strcasecmp(dom, "INET6") ||
+			   !strcasecmp(dom, "AF_INET6") ||
+			   !strcasecmp(dom, "PF_INET6")) {
+			config[config_cnt].domain = AF_INET6;
+		} else if (!strcasecmp(dom, "IB") ||
+			   !strcasecmp(dom, "AF_IB") ||
+			   !strcasecmp(dom, "PF_IB")) {
+			config[config_cnt].domain = AF_IB;
+		} else if (strcmp(dom, "*")) {
+			continue;
+		}
+
+		if (!strcasecmp(type, "STREAM") ||
+		    !strcasecmp(type, "SOCK_STREAM")) {
+			config[config_cnt].type = SOCK_STREAM;
+		} else if (!strcasecmp(type, "DGRAM") ||
+			   !strcasecmp(type, "SOCK_DGRAM")) {
+			config[config_cnt].type = SOCK_DGRAM;
+		} else if (strcmp(type, "*")) {
+			continue;
+		}
+
+		if (!strcasecmp(proto, "TCP") ||
+		    !strcasecmp(proto, "IPPROTO_TCP")) {
+			config[config_cnt].protocol = IPPROTO_TCP;
+		} else if (!strcasecmp(proto, "UDP") ||
+			   !strcasecmp(proto, "IPPROTO_UDP")) {
+			config[config_cnt].protocol = IPPROTO_UDP;
+		} else if (strcmp(proto, "*")) {
+			continue;
+		}
+
+		if (strcmp(prog, "*")) {
+		    if (!(config[config_cnt].name = strdup(prog)))
+			    continue;
+		}
+
+		config_cnt++;
+	}
+
+	fclose(fp);
+	if (config_cnt)
+		atexit(free_config);
+}
+
+static int intercept_socket(int domain, int type, int protocol)
+{
+	int i;
+
+	if (!config_cnt)
+		return 1;
+
+	if (!protocol) {
+		if (type == SOCK_STREAM)
+			protocol = IPPROTO_TCP;
+		else if (type == SOCK_DGRAM)
+			protocol = IPPROTO_UDP;
+	}
+
+	for (i = 0; i < config_cnt; i++) {
+		if ((!config[i].name ||
+		     !strncasecmp(config[i].name, program_invocation_short_name,
+				  strlen(config[i].name))) &&
+		    (!config[i].domain || config[i].domain == domain) &&
+		    (!config[i].type || config[i].type == type) &&
+		    (!config[i].protocol || config[i].protocol == protocol))
+			return 1;
+	}
+
+	return 0;
+}
+
 static int fd_open(void)
 {
 	struct fd_info *fdi;
@@ -308,6 +441,7 @@
 	rs.fcntl = dlsym(RTLD_DEFAULT, "rfcntl");
 
 	getenv_options();
+	scan_config();
 	init = 1;
 out:
 	pthread_mutex_unlock(&mut);
@@ -404,10 +538,11 @@
 	static __thread int recursive;
 	int index, ret;
 
-	if (recursive)
+	init_preload();
+
+	if (recursive || !intercept_socket(domain, type, protocol))
 		goto real;
 
-	init_preload();
 	index = fd_open();
 	if (index < 0)
 		return index;
diff -Nur librdmacm-1.0.19/src/rsocket.c librdmacm-1.0.19.ssa1/src/rsocket.c
--- librdmacm-1.0.19/src/rsocket.c	2014-07-17 00:30:15.000000000 +0200
+++ librdmacm-1.0.19.ssa1/src/rsocket.c	2015-01-22 18:11:29.000000000 +0100
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2008-2013 Intel Corporation.  All rights reserved.
+ * Copyright (c) 2008-2014 Intel Corporation.  All rights reserved.
  *
  * This software is available to you under a choice of one of two
  * licenses.  You may choose to be licensed under the terms of the GNU
@@ -381,6 +381,7 @@
 	dlist_entry	  iomap_list;
 	dlist_entry	  iomap_queue;
 	int		  iomap_pending;
+	int		  unack_cqe;
 };
 
 #define DS_UDP_TAG 0x55555555
@@ -967,9 +968,6 @@
 		return;
 	}
 
-	if (rs->index >= 0)
-		rs_remove(rs);
-
 	if (rs->rmsg)
 		free(rs->rmsg);
 
@@ -993,11 +991,16 @@
 
 	if (rs->cm_id) {
 		rs_free_iomappings(rs);
-		if (rs->cm_id->qp)
+		if (rs->cm_id->qp) {
+			ibv_ack_cq_events(rs->cm_id->recv_cq, rs->unack_cqe);
 			rdma_destroy_qp(rs->cm_id);
+		}
 		rdma_destroy_id(rs->cm_id);
 	}
 
+	if (rs->index >= 0)
+		rs_remove(rs);
+
 	fastlock_destroy(&rs->map_lock);
 	fastlock_destroy(&rs->cq_wait_lock);
 	fastlock_destroy(&rs->cq_lock);
@@ -1174,9 +1177,14 @@
 	rs = idm_lookup(&idm, socket);
 	if (!rs)
 		return ERR(EBADF);
-	ret = rdma_listen(rs->cm_id, backlog);
-	if (!ret)
-		rs->state = rs_listening;
+
+	if (rs->state != rs_listening) {
+		ret = rdma_listen(rs->cm_id, backlog);
+		if (!ret)
+			rs->state = rs_listening;
+	} else {
+		ret = 0;
+	}
 	return ret;
 }
 
@@ -1965,9 +1973,12 @@
 
 	ret = ibv_get_cq_event(rs->cm_id->recv_cq_channel, &cq, &context);
 	if (!ret) {
-		ibv_ack_cq_events(rs->cm_id->recv_cq, 1);
+		if (++rs->unack_cqe >= rs->sq_size + rs->rq_size) {
+			ibv_ack_cq_events(rs->cm_id->recv_cq, rs->unack_cqe);
+			rs->unack_cqe = 0;
+		}
 		rs->cq_armed = 0;
-	} else if (errno != EAGAIN) {
+	} else if (!(errno == EAGAIN || errno == EINTR)) {
 		rs->state = rs_error;
 	}
 
@@ -2383,7 +2394,7 @@
 	struct rsocket *rs;
 	size_t left = len;
 	uint32_t end_size, rsize;
-	int ret;
+	int ret = 0;
 
 	rs = idm_at(&idm, socket);
 	if (rs->type == SOCK_DGRAM) {
@@ -2410,7 +2421,6 @@
 				break;
 		}
 
-		ret = 0;
 		if (flags & MSG_PEEK) {
 			left = len - rs_peek(rs, buf, left);
 			break;
@@ -2445,7 +2455,7 @@
 	} while (left && (flags & MSG_WAITALL) && (rs->state & rs_readable));
 
 	fastlock_release(&rs->rlock);
-	return ret ? ret : len - left;
+	return (ret && left == len) ? ret : len - left;
 }
 
 ssize_t rrecvfrom(int socket, void *buf, size_t len, int flags,
